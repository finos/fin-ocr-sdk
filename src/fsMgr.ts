/**
 * Copyright (c) 2024 Capital One
*/
import { Util } from "./util.js";
import { FSFileInfo, FSFileType, FSDirValue, OSFileSystem } from "./fsInterfaces.js";
import { root } from "./files.js";

export class FSMgr {

    public static build(dir: string, outFile: string, fs: OSFileSystem) {
        const ocrFS = new FSMgr(outFile, fs);
        ocrFS.build(dir);
    }

    public static async load(): Promise<FSFile> {
        try {
            return new FSFile(root);
        } catch(e: any) {
            console.warn(`Failed loading files: ${e.message}`);
            // Return an empty directory
            return new FSFile({type: FSFileType.DIR, value: {}})
        }
    }

    private readonly outFile: string;
    private readonly fs: OSFileSystem;
    private _indent = "";
    private _nl = true;

    constructor (outFile: string, fs: OSFileSystem) {
        this.outFile = outFile;
        this.fs = fs;
    }

    private async build(dir: string) {
        console.log(`Building ${this.outFile}`);
        this.writeLine(`// This file was generated by FSMgr.build`);
        this.appendLine(`import { FSFileType, FSFileInfo } from './fsInterfaces.js';`);
        this.appendLine(`export const root: FSFileInfo = {`);
        this.build2(dir);
        this.appendLine(`};`);
        console.log(`Built ${this.outFile}`);
    }

    private build2(path: string) {
        this.indent();
        if (this.fs.isDir(path)) {
            this.appendLine(`type: FSFileType.DIR,`);
            this.appendLine(`value: {`);
            this.indent();
            const files = this.fs.readDir(path);
            for (const name of files) {
                this.appendLine(`"${name}": {`);
                this.build2(this.fs.pathJoin(path, name));
                this.appendLine(`},`);
            }
            this.unindent();
            this.appendLine(`},`);
        } else {
            const value = Util.bufferToBase64(this.fs.readFile(path));
            this.appendLine(`type: FSFileType.FILE,`);
            this.appendLine(`value: "${value}",`);
        }
        this.unindent();
    }

    private writeLine(str: string) {
        this.fs.writeFile(this.outFile, Buffer.from(`${this._indent}${str}\n`));
        this._nl = true;
    }

    private appendLine(str: string, noNL?: boolean) {
        const indent = this._nl ? this._indent : "";
        this._nl = !noNL;
        this.fs.appendFile(this.outFile, Buffer.from(`${indent}${str}${noNL?"":"\n"}`));
    }

    private indent() {
        this._indent = `${this._indent}  `;
    }

    private unindent() {
        this._indent = this._indent.slice(2);
    }
}

export class FSFile {

    private readonly fi: FSFileInfo;

    constructor(fi: FSFileInfo) {
        this.fi = fi;
    }

    public exists(name: string): boolean {
        return this.getFileInfo(name) !== undefined;
    }

    public listFileNames(): string[] {
        const val = this.getDirValue();
        const fileNames =  Object.keys(val);
        return fileNames;
    }

    public getFile(name: string): FSFile {
       const fi = this.getFileInfo(name);
       if (!fi) throw new Error(`'${name}' does not exist`);
       return new FSFile(fi);
    }

    public readFile(name: string): ArrayBuffer {
        const buf = this.getFile(name).read();
        return buf;
    }

    public readString(name: string): String {
        const buf = this.readFile(name);
        var decoder = new TextDecoder ();
        return decoder.decode (buf);
    }

    public read(): ArrayBuffer {
        this.assertFile();
        return Util.base64ToBuffer(this.fi.value as string);
    }

    public isDir(): boolean {
        return this.fi.type === FSFileType.DIR;
    }

    public isFile(): boolean {
        return this.fi.type === FSFileType.FILE;
    }

    private getFileInfo(name: string): FSFileInfo | undefined {
       return this.getDirValue()[name];
    }

    private getDirValue(): FSDirValue {
       this.assertDir(); 
       return this.fi.value as FSDirValue;
    }

    private assertDir() {
        if (!this.isDir()) throw new Error(`Not a directory`);
    }

    private assertFile() {
        if (!this.isFile()) throw new Error(`Not a file`);
    }

}
